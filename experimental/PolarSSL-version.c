#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//Tsubasa Kato 2025/1/7 12:51AM JST
//This code has not been tested to work. Please consider it as a base of trying to make a text browser that can do SSL.
//It has been generated by ChatGPT o1. It also does not check certificate.
//I am not even sure if it supports modern TLS for this code.
// PolarSSL 1.3.x (sample) headers
#include "polarssl/net.h"
#include "polarssl/ssl.h"
#include "polarssl/x509_crt.h"
#include "polarssl/havege.h"

// This callback disables certificate verification checks entirely
static int my_verify(void *data, x509_crt *crt, int depth, int *flags)
{
    // Wipe out any flags (in effect, saying "cert is fine")
    *flags = 0;
    return 0; 
}

int main(int argc, char *argv[])
{
    if (argc < 2) {
        printf("Usage: %s <url>\n", argv[0]);
        return -1;
    }

    // Naive parse: http:// or https://
    // In a real browser, you'd parse the path, port, etc.
    const char *url = argv[1];
    char host[256] = {0};
    int is_https = 0;
    int ret;
    int port = 80;

    if (!strncmp(url, "https://", 8)) {
        is_https = 1;
        port = 443;
        strcpy(host, url + 8);
    } else if (!strncmp(url, "http://", 7)) {
        is_https = 0;
        port = 80;
        strcpy(host, url + 7);
    } else {
        // default to HTTP
        strcpy(host, url);
    }

    // Remove any trailing slash or path
    char *slash = strchr(host, '/');
    if (slash) {
        *slash = '\0';
    }

    net_context server_fd;
    ssl_context ssl;
    ssl_init(&ssl);

    // We'll need a random source. PolarSSL 1.x often uses HAVEGE or entropy/ctr_drbg
    havege_state hs;
    havege_init(&hs);

    // Connect a TCP socket to the remote host
    char port_str[16];
    sprintf(port_str, "%d", port);
    if ((ret = net_connect(&server_fd, host, port_str)) != 0) {
        printf("Failed to connect: -0x%04x\n", -ret);
        return -1;
    }

    if (!is_https) {
        // Plain HTTP: just send/receive
        char request[512];
        snprintf(request, sizeof(request),
                 "GET / HTTP/1.0\r\nHost: %s\r\n\r\n", host);
        net_send(&server_fd, (unsigned char*)request, strlen(request));

        char buf[512];
        while ((ret = net_recv(&server_fd, (unsigned char*)buf, sizeof(buf)-1)) > 0) {
            buf[ret] = 0;
            printf("%s", buf);
        }
        net_close(&server_fd);
        return 0;
    }

    // HTTPS: set up SSL
    ssl_init(&ssl);
    ssl_set_endpoint(&ssl, SSL_IS_CLIENT);
    ssl_set_authmode(&ssl, SSL_VERIFY_OPTIONAL);
    ssl_set_rng(&ssl, havege_rand, &hs);
    ssl_set_bio(&ssl, net_recv, &server_fd, net_send, &server_fd);
    
    // Provide a callback to skip cert checks
    ssl_set_ciphersuites(&ssl, ssl_list_ciphersuites());
    ssl_set_verify(&ssl, my_verify, NULL);

    // Start the TLS handshake
    while ((ret = ssl_handshake(&ssl)) != 0) {
        if (ret != POLARSSL_ERR_NET_WANT_READ && ret != POLARSSL_ERR_NET_WANT_WRITE) {
            printf("ssl_handshake() failed: -0x%04x\n", -ret);
            net_close(&server_fd);
            return -1;
        }
    }

    // Send a basic request
    char request[512];
    snprintf(request, sizeof(request),
             "GET / HTTP/1.0\r\nHost: %s\r\n\r\n", host);
    if ((ret = ssl_write(&ssl, (unsigned char*)request, strlen(request))) <= 0) {
        printf("ssl_write() failed: -0x%04x\n", -ret);
        ssl_close_notify(&ssl);
        net_close(&server_fd);
        return -1;
    }

    // Read response
    char buf[512];
    do {
        memset(buf, 0, sizeof(buf));
        ret = ssl_read(&ssl, (unsigned char*)buf, sizeof(buf)-1);
        if (ret > 0) {
            buf[ret] = 0;
            printf("%s", buf);
        }
    } while (ret > 0);

    // Cleanup
    ssl_close_notify(&ssl);
    net_close(&server_fd);
    ssl_free(&ssl);
    havege_free(&hs);

    return 0;
}
